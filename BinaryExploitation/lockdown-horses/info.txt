The program is using the seccomp feature of linux kernel
we can see the seccomp filter with seccomp-tools
    seccomp-tools dump ./horse

Inference with seccomp filter
    The syscalls we can use
        open
        mmap
        exit
        getdents64
        exit_group
        read - in fd 0 only - stdin
        write - in fd 1 only - stdout
    The arch should only ARCH_X86_64

arguments in function call
    1st argument goes to rdi. 
    2nd argument goes to rsi. 
    3rd argument goes to rdx 
    4th argument goes to rcx. 
    5th argument goes to r8. 
    6th argument goes to r9. 
    7th argument goes to stack. 

arguments in syscall
    1st argument goes to rdi. 
    2nd argument goes to rsi. 
    3rd argument goes to rdx 
    4th argument goes to r10. 
    5th argument goes to r8. 
    6th argument goes to r9. 
    7th argument goes to stack. 

Info gathering
    The flag is stored in /srv/app/flag-[random_number].txt
    To read the file name we can use getdents64 syscalls
        used to get directory entries
        the struct definition of linux_dirent
            struct dirent {
               ino_t          d_ino;       /* Inode number */
               off_t          d_off;       /* Not an offset; see below */
               unsigned short d_reclen;    /* Length of this record */
               unsigned char  d_type;      /* Type of file; not supported
                                              by all filesystem types */
               char           d_name[256]; /* Null-terminated filename */
           };
        use
    read plt address - 0x400790
    read got address - 0x601fd8
    write plt address - 0x400740
    write got address - 0x601fb0
    libc version from docker file - 2.31(in remote)/ 2.36(in local)
        to link it /home/ayush/.cargo/bin/pwninit --libc libc.so.6 --no-template --bin horse  
    syscalls
        open - 2    
        getdents64 - 217
        mmaps - 9


Exploit
    To make the stack overflow large enough to make ROP chain attack
        the stack memory is very small to make any ROP chain
        we will need a new place in any writeable section for a new stack and make the stack pointer point to the new place
            this is called stack pivoting
        we can control the rsp pointer with gadgets
        After making a new stack we also have stack overflow with new offset - 24
            this is due to three pop statements after the pop rsp pointer
        now we can write a new ROP with much larger limit
    To make random func call
        to control the rdi, rsi, rdx pointers and making a "call" syscall we need to get that gadget from csu lib
            this is called ret2csu
        we have two types of gadgets in this function(__libc_csu_init)  
            one to change register values and one to make call syscall
    To get libc base address  
        we need to make func call write(1, read_got, 8)
        after that we need to make the new stack overflow so that we can make exploit on the basis of the libc functions
        this new stack starts from 0x602200 to make sure it is not overwritten by the next stack overflow that will happen in 0x602000
    finding flag file name
        we need to open the current directory in ib a file descriptor(by default first free fd will be assigned)
            this fd will be returned in rax if everything works fine
            in this case the fd will be 3
        we can now call getdents to store dirents in memory in addr 0x602e00
        we need to call write to read values of file name in dirent
        Now again after knowing the filename we need to setup next stack overflow
        we also need to store the filename in the stack which we will use later to open in an fd
    reading flag in memory
        we need to call open on the address where the filename is stored
            the fd we will get from this open call will be 4(as 3 is already assigned to previous open)
        now once we have opened a fd we can also check it with  
            in gdb
                info proc
                to identify process id
            in cmd
                ls -l /proc/{proc_id}/fd
        Now we can call mmap on this fd(4)
            we need to specify 6 arguments (in syscall manner)
            the address we need to store should be in heap area
                otherwise i was getting -22
                we can choose 0x603000
            we also need to specify flags
                to get the values of mmap flags
                echo '#include <sys/mman.h>' | gcc -E - -dM | grep MAP_
                we need to have MAP_FIXED flag to make sure the mmap stores the content of the file in the specified location
            we can call write to read from the 0x603000 memory addr