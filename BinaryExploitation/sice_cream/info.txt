the checksec gives the following
    Arch:     amd64-64-little
    RELRO:    Full RELRO
    Stack:    Canary found
    NX:       NX enabled
    PIE:      No PIE (0x400000)
    RUNPATH:  b'./'

This means the GOT is non writeable but PIE is disabled

Ghidra analysis
    there is a function that reads the content of a file given the file name
        the char* to the string
        starts at 0x00400cc4
    Name is asked in the start of the process
        store in 0x602040
        can be of size 0x100
    the three options in menu
        Option 1(Buy)
            checks if we can buy - limit is 20 cream can be stored 
            asks the max length of a string to be input and the string
                string is flavor
            mallocs the flavor length and stores the address in the 0x602140 + i*8 space for the ith sice cream
            max limit to cream flavor - 0x58
            the cream array is store directly below the name buffer 
        Option 2(Eat)
            asks for the index of cream to free (lets say i)
            checks the index should be less than 20
                indexing starts from 0
            frees a memory 0x602140 + i*8
                does not NULL out the content
                this can cause double free vuln
        Option 3(Reintro)
            read 0x100 bytes and write in 0x602040 
            then reads the string again
                potential info leak
        Option 4(Exit)
            leaves program with a smug message

Leak libc address
    Store a chunk in unsorted bin and print the value of the chunk as string
        Why we need to make a fake chunk 
            Normal cream chunks when freed will be stored in the fast bin as their size is limited by 0x58
            we also need the ability to read from the chunk in the unsorted bin for info leak
        To store a chunk in the unsorted bin we need to use the double free vuln 
            with the help of double free we will extent the fast bin to add the fake chunk in 0x602130 before tail
                now when we ask of a chunk same size as the fake chunk at 0x602130 we will get the fake chunk and now we can write anything to 0x602140
                as this is the start of the cream array we can say that we can write the first cream chunk address to 0x602040 and free this fake small bin chunk with our choosen size with eat(0)
            fake small bin chunk starts with 0x602040(with size 0xc1) and will be printed with option 3
            all we need to do is push a fake chunk which starts at 0x602040 into the unsorted bin
                as it will be the first chunk in the unsorted bin we will have the unsorted bin base address(the main arena address as the backward pointer of this chunk)
        Procedure
            buy cream two times to allocate cream A and B chunks
                let the size for the flavor be 20 and the flavor be "aaaaaaaaaaaaaaaaaaaa"
            free chunk A and then B and then A again
                this will make the fast bin similar to 
                    head -> A -> B -> A -> tail
                we are using B as a safety option to bypass the "double free or corruption (fasttop)" check
            Now buy two more sice cream(with same flavor length) to allocate cream C and D chunks 
                as the fast bin follows LIFO pattern
                    C and D will be same as A and B respectively
                Now set the flavor string for the C chunk as 0x602130
                    0x10 less than the start of the cream array
                    this will make the forward pointer of the A chunk in fast bin as 0x602130
                        this will make the fast bin similar to 
                            head -> A -> 0x602130
            Now make the name string as the following buffer 
                [name]
                0x602040:    0x0000000000000000    0x00000000000000c1 <-- fake smallbin chunk header
                0x602050:    0x0000000000000000    0x0000000000000000 <-- fake smallbin chunk data
                0x602060:    0x0000000000000000    0x0000000000000000
                0x602070:    0x0000000000000000    0x0000000000000000
                0x602080:    0x0000000000000000    0x0000000000000000
                0x602090:    0x0000000000000000    0x0000000000000000
                0x6020a0:    0x0000000000000000    0x0000000000000000
                0x6020b0:    0x0000000000000000    0x0000000000000000
                0x6020c0:    0x0000000000000000    0x0000000000000000
                0x6020d0:    0x0000000000000000    0x0000000000000000
                0x6020e0:    0x0000000000000000    0x0000000000000000
                0x6020f0:    0x0000000000000000    0x0000000000000000
                0x602100:    0x00000000000000c1    0x0000000000000031 <-- intermediary chunk header
                0x602110:    0x0000000000000000    0x0000000000000000
                0x602120:    0x0000000000000000    0x0000000000000000
                0x602130:    0x0000000000000000    0x0000000000000041 <-- fake chunk header (above `creams`)
                [creams]
                0x602140:    ...
            Now buy two sice cream(E and F) with first flavor length as 20 and second flavor length as 0x40(64)
                E will be A chunk and F will be the fake chunk starting at 0x602130
                for flavor strings 
                    E - anything
                    F - 0x602040
            Now free the cream F
                this will add the chunk at 0x602040 at unsorted bin 
            Now with option 4 print the value at 0x602040 address with new name of 16 bytes(to make sure we get the fd and bk pointers)
                first 16 bytes can have null char
                "A"*16 will work

Operating House of Orange
    we need to find the _IO_list_all address and the system GOT address from the libc address we leaked
    we then need to use the unsorted bin attack to change the _IO_list_all value to point to main arena
    we need to make sure the fake chunk we have in 0x602040 is moved to small bin[4] with system GOT address stored in ... and /bin/sh\x00 on start of 0x602040
        we need to make the size of the fake chunk 0x61 and the first value as /bin/sh\x00
        we need to set the bk pointer to _IO_list_all address - 0x10
            we need to do -0x10 as the chunk->bk->fd will be written with unsorted bin start address
            ->fd is nothing but +0x10
        we need to make sure some values are set accordingly so that this fake chunk is considered as valid chunk
            fp->_mode = 0; // top+0xc0
            fp->_IO_write_base = (char *) 2; // top+0x20
            fp->_IO_write_ptr = (char *) 3; // top+0x28  
        the vtable for this fp(file pointer which is also the fake chunk) need to be overwritten with system GOT address
            fp->vtable = SYSTEM // top+0x30 to top+0xb0 
            the actual address of the vtable is stored at top+0xd8
            we need to make the top+0xd0 -> 0 and top+0xd8 -> vtable address(top+0x60)
    now we need to make sure this fake chunk with fake IO_struct goes into the small bin[4] 
        we need to make a malloc call for chunk less than the 0x58 size
            this will make the heap manager to sort the fake chunk into the small_bin
            we can make the cream with 40 size
    in the end we need to send the command we need to execute as once the memory corruption happens the shell will break
Flag - flag{th3_r3al_questi0n_is_why_1s_libc_2.23_still_4_th1ng_2c4930c6}



        


