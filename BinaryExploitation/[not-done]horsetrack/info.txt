aaaaaaaaaaaaaaaa
not able to solve this (locally it is working but remote is not working)
    links to revisit
        https://www.youtube.com/watch?v=6c4QSlJJADA
        https://github.com/AlexSutila/picoCTF-2023-writeups/blob/main/horsetrack/horsetrack.md
stable struct
    16 bytes size
    first 8 bytes store address to the horse name string
    next 4 bytes store the stable number
        this value is changed with hidden option
        if this value is greater than 29 we will be caught cheating
            there is a global variable to catch cheating
            it is cheat_check which when non zero prints amessage that you have been cheating and exits the program
    next 4 bytes store if the stable have horse or not
        atleast 5 horses to race

vulnerabilities
    in the remove_horse function we have free(stable.name)
        this will not set the name to null so we can use it after free
    the cheat function use the horse name without checking if it is deleted or not
        we can use it for use-after-free
    the cheat function calls get_horse_name() which breaks if the input character -1(when casted to char is 0xff) without changing the original horse name
        this will help in the info leak

address of stack in heap    
    not found
info proc mappings
    to find address space division
address of stack in libc
    find 0x7ffff7dfb000, 0x7ffff7fbb000, 0x7ffffffe
    we have 0x7ffff7ed8220 libc address(with atoi at 0x00007ffff7e38a20 ==> libc base at ==> offset is )
        which store stack address 0x7ffffffe3c247c81
return address of main rsp(0x7fffffffdcf8) - 0x7ffff7e227ed

What we are doing (plan)
    we are trying to get an arbitrary write in the process memory with the heap exploit
    we are trying to manipulate the heap allocator to give us chunks with addresses of our choice with write permissions so we can edit them with changing horsename
        we need to know the safe linking aslr address first
    After we get arbitrary write in the process memory we can make a ROP attack by changing the return pointer of the main and making it point to system call in libc with /bin/sh parameter
        we need to know the aslr address of libc and the stack where the return address of the main function is stored
How to get an arbitrary write
    first we need to find the safe linking aslr address
        we can include different stable struct in tcache bin by first allocating then and then removing them and then adding them again without changing the value inside the user data
            inside the user data the first 8 bytes will be the forward pointer of the tcache
        as the tcache is empty the actual next pointer is null(so zero) 
        the fd pointer stored in the tcache chunk will be aslr address ^ null == aslr address
        as now all the horses in the stables contains the aslr address we can race them and the winner will have the aslr address
    after finding the safe linking aslr address we need to fool the allocation manager
        we can store two chunks in the tcache bin 
        manipulate the fd pointer of the first chunk to point to the arbitrary location we want to write to
        now we can call malloc on both chunks to get the first chunk as it is but the second chunk will be the arbitrary location chunk
        Now the horse name we write on the new second chunk will be written into the address we have written into the first chunk(the arbitrary one)
    To write in an already freed chunk we use the cheat option 

How to make ROP
    we need to make cheat feasible(as after one use we cannot race as a global value at 0x4040EC is set to one when we cheat and checkced at the start of the race
        in the address 0x4040E0 we have stored the address of the stdext from libc
        we can get this chunk with writing this address(xored with aslr address of safe linking) in the fd pointer of the stableone chunk and when we get the chunk from the add horse for the stable 1
        after we get this chunk from the heap allocator the next 8 bytes from the first 8 bytes will represent key in heap metadata and will be changed to zero(hence making the global veriable to check cheating will be set to zero again)
    find the libc address 
        we can now race the horses(as the stable one horse name is the leaked stderr address of libc)
            the version of libc is 2.33 we can get it form gdb into the libc and finding addresses of gets/puts/atoi
        in case the stable 1 horse wins the winner will be leaking the libc address of the stderr call
    Find the stack pointer
        i dont know he find the stack pointer in the libc
        but there is a stack pointer stored in libc where the offset to the main return pointer is 0xf8
        now as we have the stack aadress of the main ret pointer we can change it ot our payload
Normally the chunk pointer points to the user data and the actual chunk pointer is derived form it by substracting the metadata size
