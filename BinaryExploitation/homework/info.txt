Analysis
    there are multiple global variables
        can use these commands to get global variables address
            pipe info variables | grep stack
        global variable                  address                  value
        flag                             0x5555555596e0           flag as string
        board                            0x555555559260           board that contains instructions
        rows                             0x5555555596ac           max rows in board(end of board)
        cols                             0x5555555596b0           max columns in board(end of board)
        sn                               0x5555555590a0           stack pointer
        stack                            0x5555555590c0           stack base
        pcx                              0x5555555596b8           col program counter
        pcy                              0x5555555596bc           row program counter
    also after running the program the whole step function(as it is big) is stored in different location 
        0x5555555551c9
        we can also get this section with info proc mappings where we will see a space where the perms are r-xp
    the is a weird set of operation triggered by characters stored in the board variable
    the executable provides stack operations 
        stack is a global variable - array of integers 
        sn is a global variable - stack pointer(top+1 pointer)
        char                        stack/global values operation
        !                           stack[top] = (stack[top] == 0)
        $                           stack.pop()
        %                           stack[top-1] = stack[top-1]%stack[top]
                                    stack.pop() 
        *                           stack[top-1] = stack[top-1]*stack[top]
                                    stack.pop() 
        +                           stack[top-1] = stack[top-1]+stack[top]
                                    stack.pop() 
        -                           stack[top-1] = stack[top-1]-stack[top]
                                    stack.pop() 
        /                           stack[top-1] = stack[top-1]/stack[top]
                                    stack.pop() 
        ,                           print((char)(stack[top]))
                                    stack.pop() 
        .                           print((ulong)(stack[top]))
                                    stack.pop() 
        :                           stack.push(stack[top])
        \                           swap(stack[top], stack[top-1])
        `                           stack[top-1] = stack[top]<stack[top-1]
        g                           stack[top-1]=board[stack[top]][stack[top-1]]
                                    stack.pop()
                                    there are checks for 0<=stack[top]<=rows and 0<=stack[top-1]<=col
        p                           board[stack[top]][stack[top-1]]=stack[top-2]
                                    stack.pop()
                                    stack.pop()
                                    stack.pop()
                                    there are checks for 0<=stack[top]<=rows and 0<=stack[top-1]<=col
        _                           if(stack[top]==0) pcx++; else pcx--;
                                    stack.pop()
        |                           if(stack[top]==0) pcy++; else pcy--;
                                    stack.pop()
        <                           pcx--
        >                           pcx++
        ^                           pcy--
        v                           pcy++
        @                           exit(0)
        null                        stack.push(0)
    we need to get the flag value stored in memory

Exploit -
    we can change the value of rows and columns 
        the limit in the memory we can change with stack is extending beyond board limit as the limit on rows and columns are 32(instead of 31) and 16(instead of 15)
        this gives us a extended space of (0x32+0x1)=0x33
        we can reach rows and columns values but not flag values
        we need to change these values to a large number
        
    we can then read from outside the board(the address of flag)
        we need to store values in stack and fetch flag indexes
            board + 1152 till end of flag
    
    board matrix
        0!:+::+:+:+::+++::*\v
        v<<<<<<<<<<0p\+:+:!0<
        >0!+:0!:+::+:+:+::+>v
        ^<<<<<<<<<<<<<<<,g++<
    what it does
        push(2500)
        push(4)
        push(50)
        p
            changes the value in col to 2500
        push(0)
            we will print board[0x32][x]
            starting value of x=0
        loop:
            in start of loop we will have x in stack
            pop()
            push(x+1)
            push(x+1)
            push(50)
            g
                to get the value on stack
            ,
                to print the value
            continue 
        

info gathering
    define hook-stop
        x/2wx 0x555555559078
        x/40wx 0x5555555590a0
        x/20wx 0x555555559260
        x/20wx 0x5555555596ac
        end

Flag - picoCTF{good_job_full_score_X7OIj4HI903RG2YO}