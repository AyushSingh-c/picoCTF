ldd ./zero_to_hero 
    to make sure the libc file is linked correctly

checksec
    Arch:     amd64-64-little
    RELRO:    Full RELRO
    Stack:    Canary found
    NX:       NX enabled
    PIE:      No PIE (0x400000)
    RUNPATH:  b'./'


Analysis
    we have a system address leak that is libc+0x52fd0
    we have three options 
    Option 1 - get a superpower
        we can allocate 7 chunks with max size 0x408
            we need to specify length of string we need to store
            we then sent the data to write
        the address of allocated chunks are stored in form of array from 0x602060
    Option 2 - remove a superpower
        we have to give the index of the chunk we need to free  
    Option 3 - exit    
    
Vuln
    we have a double free vul in the option 2 code
        we free an address without cleaning it
    When reading into the text for the superpower, it lets us write tons of characters, and then it will append a null byte to the end of whatever we have written. However, if we asked for 40 bytes to write in, then we will get to write 40 characters, and then the null byte will be placed outside of the current chunk.
    as we have protection for double free in the libc version 2.29 we have to use the second bug/vul to bypass the protection
        Second, the only protection that tcache has against double-free is that it makes sure the current chunk being freed is different from all chunks freed earlier of the same size.

Exploit
    we will use the double free vulnerability to get a chunk that can modify __free_hook(libc+0x1e75a8) to 0x400a02(flag printing function)
        The pointer __free_hook, stored in a writable area of libc, simply redirects the actions of free() to whatever function __free_hook happens to point to, so rewriting __free_hook will make free() call an arbitrary function
    trial with gdb
        when we edit the __free_hook(0x7ffff7fc65a8) memory space with the following code and free a chunk we get the flag
            set {int}0x7ffff7fc65a8 = 0x400a02
            0x7ffff7fc65a8 <__free_hook>:	0x00400a02	0x00000000	0x00000000	0x00000000 
    simply attempting to free power 0, free power 1, and free power 0 again will fail because we are using libc 2.29. Trying this will display the following error message:
        free(): double free detected in tcache
    
    To overwrite the __free_hook address    
        Step 1: calculate __free_hook address
        Step 2: allocate chunks A, B with size 0x110
        Step 3: free chunks B, A
        Step 4: allocate chunks C with size 0x110
            this should give C as A 
        Step 5: edit the C chunk value to fully write 0x110 bytes
            this will change the size of chunk B to 0x100(instead of 0x111)
        Step 6: free chunk B
            this time as the chunk size is different so we dont get the tcache double free error
            now as we have chunk B in both tcache with size 0x100 and 0x110 we can get it with two different mallocs for size 0x100 and 0x110
        Step 7: malloc 0x110 size chunk D and write to it the __free_hook-0x10
            D will be chunk B
        Step 8: malloc 0x100 size chunks E,F 
            E will be chunk B and F should refer to __free_hook
        Step 9: write 0x400a02 in the chunk F
        Step 10: free chunk C