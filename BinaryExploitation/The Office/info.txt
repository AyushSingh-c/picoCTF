employee_struct
    0x0 - name
    0x10 - address of the email string
        LENGTH LIMIT 127
    0X14 - Salary
    0x18 - Phone
    0x24 - Bldg

top of heap - DAT_0804c078(means stored in addr 0x0804c078)
bottom of heap - DAT_0804c074(means stored in addr 0x0804c074)

To win the flag
    figure out a way to store the employee with name admin
    send that employee number in the 4th option of the menu(get access token)

remove_employee flow
    we send an employee struct data addr to freekind function
        if the email field is not 0 then the addr is employee struct data addr + 0x10 to free the user email first

to get the information about heap through gdb
    b *0x08049830   
        breakpoint in the debug check
    set {int}($ebp+0x8) = 1
        set debug variable to 1

Every employee created allocates a new chunk of Size 52 at the bottommost free location in the heap, if an email was created too then also a second chunk of Size 20 (or more, if the email is too long, actually)
    Deleting an employee deletes them from an internally kept list of employees and deallocates their chunk(s)
The large, unallocated chunk at the top of the heap grows and shrinks to accommodate added and removed employees
    The heap likes to fall apart when we delete chunks from the middle of the heap without immediately adding them back
The actual size of each chunk is actually 12 bytes more than the "Size" listed by heapcheck; the extra 12 bytes are a header at the beginning of each chunk
    The first 4 bytes (little-endian 32-bit unsigned integer) are the "Canary" as given by heapcheck (it's the same value for every chunk, but it changes every time the program is restarted and if even one chunk's Canary, even that of the unallocated top chunk or any other unallocated chunks, doesn't match the value heapcheck has stored internally, it will explode in a little ball of flame)
    The next 4 bytes are the "Size" (always an even number) plus 1 iff "Allocated"
    The last 4 bytes are the "Prev_size" (always an even number) plus 1 iff "Prev_allocated"
    Prev_size must match the Size of the previous chunk and Prev_allocated must match the Allocated of the previous chunk, or else heapcheck will throw a tantrum and say you did heap smashing
    The heap is 4096 bytes; at any given time chunks (including unallocated ones) occupy the entire heap, so if the sum of the "Size" fields of each chunk plus 12 times the number of chunks is not 4096, heapcheck will say you did heap smashing
Even the large unallocated chunk at the top of the heap has a header, so its actual size is also 12 more than its "Size"
The body (bytes that come after the header) of an email chunk are just the email as a null-terminated string
For non-email chunks the body has a different structure:
    The first 20 bytes are the name as a null-terminated string
    The next 4 bytes are salary as a little-endian 32-bit unsigned integer
    The next 12 bytes are the phone number as a null-terminated string
    The next 4 bytes are the building number as a little-endian 32-bit unsigned integer
    The last 12 bytes are unused

Exploit - 
    we have heap overflow on phone input
    we need to find canary value    
        as the canary is generated with srand(time(0)) we can sync our python code local server to remote server
            we need to guess offset for this
    

Flag - picoCTF{15508b5b47c3880178cf17150e517d5e} 